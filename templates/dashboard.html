import os, base64, threading, uvicorn, pandas as pd, json
from datetime import datetime
from fastapi import FastAPI, BackgroundTasks, Request, HTTPException, Form
from fastapi.responses import HTMLResponse, RedirectResponse, FileResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
from pydantic import BaseModel

app = FastAPI(title="LMS-Proctoring FIEE UNI")
templates = Jinja2Templates(directory="templates")

# --- CONFIGURACIÓN DE RUTAS Y SEGURIDAD ---
DB_PATH = "database.csv"
ASISTENCIA_PATH = "asistencia.csv"
RESPUESTAS_PATH = "respuestas.csv"
CLAVE_DOCENTE = "uni2026"

# Asegurar entorno (Previene el Error 500 en Render)
for folder in ["evidencias", "static/js"]:
    os.makedirs(folder, exist_ok=True)

# Inicializar archivos con encabezados correctos
def init_csv(path, columns):
    if not os.path.exists(path) or os.stat(path).st_size == 0:
        pd.DataFrame(columns=columns).to_csv(path, index=False)

init_csv(DB_PATH, ["Fecha", "ID", "Nombre", "Sala", "Falta", "Ruta"])
init_csv(ASISTENCIA_PATH, ["ID", "Nombre", "Sala", "Estado", "Camara", "Fecha"])

app.mount("/static", StaticFiles(directory="static"), name="static")
app.mount("/ver_evidencia", StaticFiles(directory="evidencias"), name="evidencias")

# --- CLASE DE ANÁLISIS DE DATOS (Patrón de diseño POO) ---
class AnalizadorDatos:
    """Clase para procesar estadísticas del examen en Python."""
    def __init__(self, db_path, asist_path):
        self.db_path = db_path
        self.asist_path = asist_path

    def obtener_resumen_estadistico(self):
        try:
            df_asist = pd.read_csv(self.asist_path)
            df_inc = pd.read_csv(self.db_path)
            
            stats = {
                "total_alumnos": len(df_asist["ID"].unique()),
                "online": len(df_asist[df_asist["Estado"] == "ONLINE"]),
                "finalizados": len(df_asist[df_asist["Estado"] == "FINALIZADO"]),
                "alertas_criticas": len(df_inc),
                "alumnos_bloqueados": len(df_asist[df_asist["Camara"] == "BLOQUEADA"])
            }
            return stats
        except Exception as e:
            print(f"Error en análisis: {e}")
            return {"total_alumnos": 0, "online": 0, "finalizados": 0, "alertas_criticas": 0, "alumnos_bloqueados": 0}

    def listar_incidencias(self):
        if not os.path.exists(self.db_path): return []
        df = pd.read_csv(self.db_path)
        return df.to_dict(orient="records")[::-1]

analizador = AnalizadorDatos(DB_PATH, ASISTENCIA_PATH)
csv_lock = threading.Lock()

# --- RUTAS ---
@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    return templates.TemplateResponse("registro.html", {"request": request})

@app.post("/ingresar")
async def ingresar(role: str = Form(...), nombre: str = Form(None), uid: str = Form(None), sala: str = Form(None), password: str = Form(None)):
    if role == "docente":
        if password == CLAVE_DOCENTE:
            return RedirectResponse(url=f"/dashboard?password={password}", status_code=303)
        return HTMLResponse("<h1>❌ Clave incorrecta</h1><a href='/'>Volver</a>", status_code=403)
    
    # Registro Estudiante
    registro = {"ID": uid, "Nombre": nombre, "Sala": sala, "Estado": "ONLINE", "Camara": "OK", "Fecha": datetime.now().strftime("%H:%M:%S")}
    with csv_lock:
        pd.DataFrame([registro]).to_csv(ASISTENCIA_PATH, mode='a', header=False, index=False)
    return RedirectResponse(url=f"/examen?uid={uid}&nombre={nombre}&sala={sala}", status_code=303)

@app.get("/examen", response_class=HTMLResponse)
async def examen(request: Request, uid: str, nombre: str, sala: str):
    return templates.TemplateResponse("cliente.html", {"request": request, "uid": uid, "nombre": nombre, "sala": sala})

@app.get("/dashboard", response_class=HTMLResponse)
async def dashboard(request: Request, password: str = None):
    if password != CLAVE_DOCENTE: return RedirectResponse("/")
    
    # Python hace el trabajo pesado aquí
    stats = analizador.obtener_resumen_estadistico()
    incidencias = analizador.listar_incidencias()
    asistencia = pd.read_csv(ASISTENCIA_PATH).to_dict(orient="records")
    
    return templates.TemplateResponse("dashboard.html", {
        "request": request, "stats": stats, "incidencias": incidencias, "asistencia": asistencia[::-1]
    })

# --- API DE ALERTAS ---
class Alerta(BaseModel):
    uid: str; nombre: str; sala: str; tipo_falta: str; imagen_b64: str; camara_ok: bool

@app.post("/api/alerta")
async def api_alerta(alerta: Alerta, bt: BackgroundTasks):
    def process():
        ts = datetime.now().strftime("%M%S")
        path = f"evidencias/{alerta.uid}_{ts}.jpg"
        # Guardado de imagen
        with open(path, "wb") as f: f.write(base64.b64decode(alerta.imagen_b64.split(",")[1]))
        
        # Actualización de estado si la cámara falla
        if not alerta.camara_ok:
            with csv_lock:
                df = pd.read_csv(ASISTENCIA_PATH)
                df.loc[df['ID'] == alerta.uid, 'Camara'] = "BLOQUEADA"
                df.to_csv(ASISTENCIA_PATH, index=False)
        
        # Registro de incidencia
        reg = {"Fecha": datetime.now().strftime("%H:%M:%S"), "ID": alerta.uid, "Nombre": alerta.nombre, "Sala": alerta.sala, "Falta": alerta.tipo_falta, "Ruta": path}
        with csv_lock: pd.DataFrame([reg]).to_csv(DB_PATH, mode='a', header=False, index=False)
    
    bt.add_task(process)
    return {"status": "ok"}

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 8000))
    uvicorn.run("app:app", host="0.0.0.0", port=port)
